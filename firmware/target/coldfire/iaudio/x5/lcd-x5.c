/***************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * $Id$
 *
 * Copyright (C) 2004 by Linus Nielsen Feltzing
 *
 * All files in this archive are subject to the GNU General Public License.
 * See the file COPYING in the source tree root for full license agreement.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ****************************************************************************/
#include "config.h"

#include "cpu.h"
#include "lcd.h"
#include "kernel.h"
#include "thread.h"
#include <string.h>
#include <stdlib.h>
#include "file.h"
#include "debug.h"
#include "system.h"
#include "font.h"
#include "bidi.h"

static bool display_on=false; /* is the display turned on? */

/* register defines for the Renesas HD66773R */
#define R_HORIZ_RAM_ADDR_POS    0x16
#define R_VERT_RAM_ADDR_POS     0x17
#define R_RAM_ADDR_SET  0x21
#define R_WRITE_DATA_2_GRAM 0x22

/*****************************************************
The table below was generated by the following script:

#!/usr/bin/perl

# high byte table
print "short high8to9[] = {\n";
$str = "  ";
for my $m (0 .. 255) {
    # RRRRRGGG => RRRRR0GGG
    my $v = (($m & 0xF8) << 1) | ($m & 0x07);
    if(length($str) > 75) {
        print "$str\n";
        $str="  ";
    }
    $str .= sprintf("0x%03x, ", $v);
}
print "$str\n};\n";

*****************************************************/

/* Lookup table for 16->18bit conversion, high byte. The low byte is just
   shifted. */
const short high8to9[] ICONST_ATTR = {
  0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007, 0x010, 0x011, 0x012,
  0x013, 0x014, 0x015, 0x016, 0x017, 0x020, 0x021, 0x022, 0x023, 0x024, 0x025,
  0x026, 0x027, 0x030, 0x031, 0x032, 0x033, 0x034, 0x035, 0x036, 0x037, 0x040,
  0x041, 0x042, 0x043, 0x044, 0x045, 0x046, 0x047, 0x050, 0x051, 0x052, 0x053,
  0x054, 0x055, 0x056, 0x057, 0x060, 0x061, 0x062, 0x063, 0x064, 0x065, 0x066,
  0x067, 0x070, 0x071, 0x072, 0x073, 0x074, 0x075, 0x076, 0x077, 0x080, 0x081,
  0x082, 0x083, 0x084, 0x085, 0x086, 0x087, 0x090, 0x091, 0x092, 0x093, 0x094,
  0x095, 0x096, 0x097, 0x0a0, 0x0a1, 0x0a2, 0x0a3, 0x0a4, 0x0a5, 0x0a6, 0x0a7,
  0x0b0, 0x0b1, 0x0b2, 0x0b3, 0x0b4, 0x0b5, 0x0b6, 0x0b7, 0x0c0, 0x0c1, 0x0c2,
  0x0c3, 0x0c4, 0x0c5, 0x0c6, 0x0c7, 0x0d0, 0x0d1, 0x0d2, 0x0d3, 0x0d4, 0x0d5,
  0x0d6, 0x0d7, 0x0e0, 0x0e1, 0x0e2, 0x0e3, 0x0e4, 0x0e5, 0x0e6, 0x0e7, 0x0f0,
  0x0f1, 0x0f2, 0x0f3, 0x0f4, 0x0f5, 0x0f6, 0x0f7, 0x100, 0x101, 0x102, 0x103,
  0x104, 0x105, 0x106, 0x107, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116,
  0x117, 0x120, 0x121, 0x122, 0x123, 0x124, 0x125, 0x126, 0x127, 0x130, 0x131,
  0x132, 0x133, 0x134, 0x135, 0x136, 0x137, 0x140, 0x141, 0x142, 0x143, 0x144,
  0x145, 0x146, 0x147, 0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157,
  0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0x170, 0x171, 0x172,
  0x173, 0x174, 0x175, 0x176, 0x177, 0x180, 0x181, 0x182, 0x183, 0x184, 0x185,
  0x186, 0x187, 0x190, 0x191, 0x192, 0x193, 0x194, 0x195, 0x196, 0x197, 0x1a0,
  0x1a1, 0x1a2, 0x1a3, 0x1a4, 0x1a5, 0x1a6, 0x1a7, 0x1b0, 0x1b1, 0x1b2, 0x1b3,
  0x1b4, 0x1b5, 0x1b6, 0x1b7, 0x1c0, 0x1c1, 0x1c2, 0x1c3, 0x1c4, 0x1c5, 0x1c6,
  0x1c7, 0x1d0, 0x1d1, 0x1d2, 0x1d3, 0x1d4, 0x1d5, 0x1d6, 0x1d7, 0x1e0, 0x1e1,
  0x1e2, 0x1e3, 0x1e4, 0x1e5, 0x1e6, 0x1e7, 0x1f0, 0x1f1, 0x1f2, 0x1f3, 0x1f4,
  0x1f5, 0x1f6, 0x1f7,
};

/* called very frequently - inline! */
inline void lcd_write_reg(int reg, int val)
{
    *(volatile unsigned short *)0xf0008000 = (reg >> 8) << 1;
    *(volatile unsigned short *)0xf0008000 = (reg & 0xff) << 1;
    *(volatile unsigned short *)0xf0008002 = (val >> 8) << 1;
    *(volatile unsigned short *)0xf0008002 = (val & 0xff) << 1;
}

/* called very frequently - inline! */
inline void lcd_begin_write_gram(void)
{
    *(volatile unsigned short *)0xf0008000 = (R_WRITE_DATA_2_GRAM >> 8) << 1;
    *(volatile unsigned short *)0xf0008000 = (R_WRITE_DATA_2_GRAM & 0xff) << 1;
}

/* called very frequently - inline! */
inline void lcd_write_data(const unsigned short* p_bytes, int count) ICODE_ATTR;
inline void lcd_write_data(const unsigned short* p_bytes, int count)
{
    unsigned int tmp;
    unsigned int *ptr = (unsigned int *)p_bytes;
    bool extra;

    /* if there's on odd number of pixels, remmber this and output the
       trailing pixel after the loop */
    extra = (count&1)?true:false;

    count >>= 1;
    while(count--) {
        tmp = *ptr++;
        *(volatile unsigned short *)0xf0008002 = high8to9[tmp >> 24];
        *(volatile unsigned short *)0xf0008002 = tmp>>15;
        *(volatile unsigned short *)0xf0008002 = high8to9[(tmp >> 8)&255];
        *(volatile unsigned short *)0xf0008002 = tmp<<1;
    }
    if(extra) {
        /* the final "spare" pixel */
        unsigned short read = *(unsigned short *)ptr;
        *(volatile unsigned short *)0xf0008002 = high8to9[read >> 8];
        *(volatile unsigned short *)0xf0008002 = read<<1;
    }
}

/*** hardware configuration ***/

void lcd_set_contrast(int val)
{
    (void)val;
}

void lcd_set_invert_display(bool yesno)
{
    (void)yesno;
}

/* turn the display upside down (call lcd_update() afterwards) */
void lcd_set_flip(bool yesno)
{
    (void)yesno;
}

/* Rolls up the lcd display by the specified amount of lines.
 * Lines that are rolled out over the top of the screen are
 * rolled in from the bottom again. This is a hardware 
 * remapping only and all operations on the lcd are affected.
 * -> 
 * @param int lines - The number of lines that are rolled. 
 *  The value must be 0 <= pixels < LCD_HEIGHT. */
void lcd_roll(int lines)
{
    (void)lines;
}

/* LCD init
 * These settings are taken from the original X5 firmware
 */
void lcd_init_device(void)
{
    display_on=true;

    /* LCD Reset */
    and_l(~0x00000010, &GPIO1_OUT);
    or_l(0x00000010, &GPIO1_ENABLE);
    or_l(0x00000010, &GPIO1_FUNCTION);
    sleep(HZ/100);
    or_l(0x00000010, &GPIO1_OUT);

    sleep(HZ/100);

    lcd_write_reg(0, 0x0001);
    
    sleep(HZ/50);
    
    lcd_write_reg(0x0d, 0x0401);
    lcd_write_reg(0x0e, 0x321e);
    lcd_write_reg(0x01, 0x0313);
    lcd_write_reg(0x02, 0x0700);
    lcd_write_reg(0x05, 0x9038);
    lcd_write_reg(0x06, 0x0000);
    lcd_write_reg(0x0b, 0x4000);
    
    sleep(HZ/100);
    
    lcd_write_reg(0x21,0x0000);
    lcd_write_reg(0x30,0x0003);
    lcd_write_reg(0x31,0x0400);
    lcd_write_reg(0x32,0x0407);
    lcd_write_reg(0x33,0x0305);
    lcd_write_reg(0x34,0x0003);
    lcd_write_reg(0x35,0x0704);
    lcd_write_reg(0x36,0x0407);
    lcd_write_reg(0x37,0x0503);
    lcd_write_reg(0x0f,0x0002);
    lcd_write_reg(0x11,0x0000);
    lcd_write_reg(0x14,0x9f00);
    lcd_write_reg(0x15,0x5c00);
    lcd_write_reg(0x16,0x7f00);
    lcd_write_reg(0x17,0x9f00);
    lcd_write_reg(0x3a,0x1409);
    lcd_write_reg(0x3b,0x0602);
    
    lcd_write_reg(0x0c,0x0001);

    sleep(HZ/25);
    
    lcd_write_reg(0x03,0x002c);
    lcd_write_reg(0x04,0x8000);

    sleep(HZ/25);
    
    lcd_write_reg(0x0e,0x3318);
    
    sleep(HZ/25);
    
    lcd_write_reg(0x0d,0x0411);

    sleep(HZ/100);
    
    lcd_write_reg(0x07,0x0006);
    lcd_write_reg(0x07,0x036);
    lcd_write_reg(0x07,0x037);
    lcd_write_reg(0x07,0x0037);
    return;
}

void lcd_enable(bool on)
{
    display_on = on;
}

/*** update functions ***/

/* Performance function that works with an external buffer
   note that by and bheight are in 8-pixel units! */
void lcd_blit(const fb_data* data, int x, int by, int width,
              int bheight, int stride)
{
    /* TODO: Implement lcd_blit() */
    (void)data;
    (void)x;
    (void)by;
    (void)width;
    (void)bheight;
    (void)stride;
    /*if(display_on)*/ 
}


/* Update the display.
   This must be called after all other LCD functions that change the display. */
void lcd_update(void) ICODE_ATTR;
void lcd_update(void)
{
    if(display_on){

        /* Copy display bitmap to hardware */
        lcd_write_reg(R_RAM_ADDR_SET, 0x0000);
        lcd_begin_write_gram();
        lcd_write_data((unsigned short *)lcd_framebuffer, LCD_WIDTH*LCD_HEIGHT);
    }
}

/* Update a fraction of the display. */
void lcd_update_rect(int, int, int, int) ICODE_ATTR;
void lcd_update_rect(int x, int y, int width, int height)
{
    if(display_on) {    
        int ymax = y + height;

        if(x + width > LCD_WIDTH)
            width = LCD_WIDTH - x;
        if (width <= 0)
            return; /* nothing left to do, 0 is harmful to lcd_write_data() */
        if(ymax >= LCD_HEIGHT)
            ymax = LCD_HEIGHT-1;

        /* set update window */ 

        /* horiz ram addr */ 
        lcd_write_reg(R_HORIZ_RAM_ADDR_POS, (ymax<<8) | y); 
        
        /* vert ram addr */ 
        lcd_write_reg(R_VERT_RAM_ADDR_POS,((x+width-1)<<8) | x); 
        lcd_write_reg(R_RAM_ADDR_SET, (x<<8) | y); 
        lcd_begin_write_gram(); 

        /* Copy specified rectangle bitmap to hardware */ 
        for (; y <= ymax; y++) 
        { 
            lcd_write_data ((unsigned short *)&lcd_framebuffer[y][x], width); 
        } 

        /* reset update window */ 
        lcd_write_reg(R_HORIZ_RAM_ADDR_POS, 0x7f00);
        lcd_write_reg(R_VERT_RAM_ADDR_POS, 0x9f00);
    }
}
