#!/bin/bash
# usage: ./genhelp.sh
#
# Expects a modified version of `halibut' to be installed in $PATH:
# https://github.com/built1n/halibut
#
# Also requires host CC and lz4 library to be available

halibut --text -Ctext-chapter-underline: src/puzzles.but

# preprocess the input

# strip leading whitespace
cat puzzles.txt | awk '{$1=$1; print}' > puzzles.txt.tmp

# cut at "Appendix A"
cat puzzles.txt.tmp | awk 'BEGIN { a=1; } /Appendix A/ { a = 0; } a==1' > puzzles.txt

rm puzzles.txt.tmp

# now split into different files
mkdir -p help

cat puzzles.txt | awk '
BEGIN {
    file = "none";
}

/#Chapter/ {
    if($0 !~ / 1:/ && $0 !~ / 2:/)
    {
        if(file != "none")
             print ";" > file;
        file = "help/"tolower($3$4)".c";

        if($3 ~ "Rectangles")
             file = "help/rect.c";

        if($3 ~ "Train")
             file = "help/tracks.c";

        print "/* auto-generated by genhelp.sh (intermediate file) */" > file;
        print "/* DO NOT EDIT! */" > file;
        print "const char help_text[] = " > file;
    }
}

file != "none" {
    /* escape backslashes */
    gsub(/\\/,"\\\\");

    if($0 ~ /\$/)
        print("WARNING: text contains dollar sign: change special character!" $0);

    /* replace underscores with dollar signs (not used in any of the puzzles docs) */
    if($0 ~ /http/)
        gsub(/_/,"$");

    begin = "";

    last = substr($0, length($0), 1);

    /* hack for chapter titles */
    if(substr($0, 1, 1) == "#" || length($0) == 0)
        term=" \\n";
    else
        term = " ";

   /* custom code markup (halibut modification required) */
   if(substr($0, 1, 2) == ">>")
   {
        gsub(/>> /,"");
        term = " \\n";
   }

    print "\"" begin $0 term "\"" > file;
}

END {
    print ";" > file;
}
'

# now compress
for f in help/*.c
do
    echo "Compressing: "$f
    gcc compress.c $f -llz4 -o compress -O0
    ./compress > $f.tmp
    mv $f.tmp $f
done

# Generate quick help by parsing the CMakeLists.txt file to isolate
# the "Objective" text for each puzzle.
cat <<EOF > parsed_cmakelists.txt
function(puzzle NAME)
  cmake_parse_arguments(OPT
    "" "DISPLAYNAME;DESCRIPTION;OBJECTIVE;WINDOWS_EXE_NAME" "" \${ARGN})

  message("\${NAME}:\${OPT_OBJECTIVE}")
endfunction()
EOF

# This parses out the puzzle(...) definitions from CMakeLists.

# TODO: Perhaps ask Simon to include special header/footer comments to
# make this less brittle?
cat src/CMakeLists.txt src/unfinished/CMakeLists.txt | awk '/puzzle\(/{p=1} p{print} /\)/{p=0}' >> parsed_cmakelists.txt
cmake -P parsed_cmakelists.txt 2>&1 | awk -F ":" '{print "const char quick_help_text[] = \""$2"\";\nconst bool quick_help_valid = true;" >> "help/"$1".c" }'

rm parsed_cmakelists.txt
rm puzzles.txt
rm compress
